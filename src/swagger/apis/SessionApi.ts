/* tslint:disable */
/* eslint-disable */
/**
 * brokerize
 * The brokerize API allows clients to implement multi-brokerage with a unified interface. For more information, visit brokerize.com
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  AddSessionCompleteChallengeParams,
  AddSessionCompleteChallengeParamsToJSON,
  AddSessionParams,
  AddSessionParamsToJSON,
  Challenge,
  ChallengeFromJSON,
  ConfirmOAuthParams,
  ConfirmOAuthParamsToJSON,
  ConfirmOAuthResponse,
  ConfirmOAuthResponseFromJSON,
  CreateTanChallengeParams,
  CreateTanChallengeParamsToJSON,
  DecoupledOperationStatus,
  DecoupledOperationStatusFromJSON,
  EnableSessionTanParams,
  EnableSessionTanParamsToJSON,
  EnableSessionTanResponse,
  EnableSessionTanResponseFromJSON,
  EndSessionTanResponse,
  EndSessionTanResponseFromJSON,
  LoginResponse,
  LoginResponseFromJSON,
  LoginResponseReady,
  LoginResponseReadyFromJSON,
  LogoutOkResponseBody,
  LogoutOkResponseBodyFromJSON,
  OkResponseBody,
  OkResponseBodyFromJSON,
  PrepareOAuthRedirectParams,
  PrepareOAuthRedirectParamsToJSON,
  PrepareOAuthRedirectResponse,
  PrepareOAuthRedirectResponseFromJSON,
  SessionResponse,
  SessionResponseFromJSON,
} from "../models";

export interface AddSessionRequest {
  addSessionParams: AddSessionParams;
}

export interface AddSessionCompleteChallengeRequest {
  addSessionCompleteChallengeParams: AddSessionCompleteChallengeParams;
}

export interface CancelDecoupledOperationLegacyRequest {
  sessionId: string;
  decoupledOperationId: string;
}

export interface ConfirmOAuthRequest {
  confirmOAuthParams: ConfirmOAuthParams;
}

export interface CreateSessionTanChallengeRequest {
  sessionId: string;
  createTanChallengeParams: CreateTanChallengeParams;
}

export interface EnableSessionTanRequest {
  sessionId: string;
  enableSessionTanParams: EnableSessionTanParams;
}

export interface EndSessionTanRequest {
  sessionId: string;
}

export interface GetDecoupledOperationStatusLegacyRequest {
  sessionId: string;
  decoupledOperationId: string;
}

export interface LogoutSessionRequest {
  sessionId: string;
}

export interface PrepareOAuthRedirectRequest {
  prepareOAuthRedirectParams: PrepareOAuthRedirectParams;
}

export interface TriggerSessionSyncRequest {
  sessionId: string;
}

/**
 *
 */
export class SessionApi extends runtime.BaseAPI {
  /**
   */
  async addSessionRaw(
    requestParameters: AddSessionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<LoginResponse>> {
    if (
      requestParameters.addSessionParams === null ||
      requestParameters.addSessionParams === undefined
    ) {
      throw new runtime.RequiredError(
        "addSessionParams",
        "Required parameter requestParameters.addSessionParams was null or undefined when calling addSession."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AddSessionParamsToJSON(requestParameters.addSessionParams),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LoginResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async addSession(
    requestParameters: AddSessionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<LoginResponse> {
    const response = await this.addSessionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * If login returns the state `challenge`, the login must be completed by providing a challenge response first.
   */
  async addSessionCompleteChallengeRaw(
    requestParameters: AddSessionCompleteChallengeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<LoginResponseReady>> {
    if (
      requestParameters.addSessionCompleteChallengeParams === null ||
      requestParameters.addSessionCompleteChallengeParams === undefined
    ) {
      throw new runtime.RequiredError(
        "addSessionCompleteChallengeParams",
        "Required parameter requestParameters.addSessionCompleteChallengeParams was null or undefined when calling addSessionCompleteChallenge."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/completeLogin`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AddSessionCompleteChallengeParamsToJSON(
          requestParameters.addSessionCompleteChallengeParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LoginResponseReadyFromJSON(jsonValue)
    );
  }

  /**
   * If login returns the state `challenge`, the login must be completed by providing a challenge response first.
   */
  async addSessionCompleteChallenge(
    requestParameters: AddSessionCompleteChallengeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<LoginResponseReady> {
    const response = await this.addSessionCompleteChallengeRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Cancel a decoupled operation.  This is deprecated, use the new `CancelDecoupledOperation` instead (which does not require the sessionId anymore).
   */
  async cancelDecoupledOperationLegacyRaw(
    requestParameters: CancelDecoupledOperationLegacyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.sessionId === null ||
      requestParameters.sessionId === undefined
    ) {
      throw new runtime.RequiredError(
        "sessionId",
        "Required parameter requestParameters.sessionId was null or undefined when calling cancelDecoupledOperationLegacy."
      );
    }

    if (
      requestParameters.decoupledOperationId === null ||
      requestParameters.decoupledOperationId === undefined
    ) {
      throw new runtime.RequiredError(
        "decoupledOperationId",
        "Required parameter requestParameters.decoupledOperationId was null or undefined when calling cancelDecoupledOperationLegacy."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/{sessionId}/decoupledOperation/{decoupledOperationId}`
          .replace(
            `{${"sessionId"}}`,
            encodeURIComponent(String(requestParameters.sessionId))
          )
          .replace(
            `{${"decoupledOperationId"}}`,
            encodeURIComponent(String(requestParameters.decoupledOperationId))
          ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Cancel a decoupled operation.  This is deprecated, use the new `CancelDecoupledOperation` instead (which does not require the sessionId anymore).
   */
  async cancelDecoupledOperationLegacy(
    requestParameters: CancelDecoupledOperationLegacyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<void> {
    await this.cancelDecoupledOperationLegacyRaw(
      requestParameters,
      initOverrides
    );
  }

  /**
   * For brokers with OAuth login processes, this adds the session to the user\'s account after redirects happen. Only the user that is redirected from the broker login in the browser will receive the `code`. This step ensures that the logged-in user at brokerize is actually the one that has gone through the broker OAuth steps.
   */
  async confirmOAuthRaw(
    requestParameters: ConfirmOAuthRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<ConfirmOAuthResponse>> {
    if (
      requestParameters.confirmOAuthParams === null ||
      requestParameters.confirmOAuthParams === undefined
    ) {
      throw new runtime.RequiredError(
        "confirmOAuthParams",
        "Required parameter requestParameters.confirmOAuthParams was null or undefined when calling confirmOAuth."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/confirmOAuth`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ConfirmOAuthParamsToJSON(requestParameters.confirmOAuthParams),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConfirmOAuthResponseFromJSON(jsonValue)
    );
  }

  /**
   * For brokers with OAuth login processes, this adds the session to the user\'s account after redirects happen. Only the user that is redirected from the broker login in the browser will receive the `code`. This step ensures that the logged-in user at brokerize is actually the one that has gone through the broker OAuth steps.
   */
  async confirmOAuth(
    requestParameters: ConfirmOAuthRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<ConfirmOAuthResponse> {
    const response = await this.confirmOAuthRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * If the user chose an auth method from `GetAuthInfo` with the flow `CHALLENGE_RESPONSE`, before enabling session TAN, a challenge must be requested first.
   */
  async createSessionTanChallengeRaw(
    requestParameters: CreateSessionTanChallengeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<Challenge>> {
    if (
      requestParameters.sessionId === null ||
      requestParameters.sessionId === undefined
    ) {
      throw new runtime.RequiredError(
        "sessionId",
        "Required parameter requestParameters.sessionId was null or undefined when calling createSessionTanChallenge."
      );
    }

    if (
      requestParameters.createTanChallengeParams === null ||
      requestParameters.createTanChallengeParams === undefined
    ) {
      throw new runtime.RequiredError(
        "createTanChallengeParams",
        "Required parameter requestParameters.createTanChallengeParams was null or undefined when calling createSessionTanChallenge."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/{sessionId}/sessiontanchallenge`.replace(
          `{${"sessionId"}}`,
          encodeURIComponent(String(requestParameters.sessionId))
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateTanChallengeParamsToJSON(
          requestParameters.createTanChallengeParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ChallengeFromJSON(jsonValue)
    );
  }

  /**
   * If the user chose an auth method from `GetAuthInfo` with the flow `CHALLENGE_RESPONSE`, before enabling session TAN, a challenge must be requested first.
   */
  async createSessionTanChallenge(
    requestParameters: CreateSessionTanChallengeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<Challenge> {
    const response = await this.createSessionTanChallengeRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async enableSessionTanRaw(
    requestParameters: EnableSessionTanRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<EnableSessionTanResponse>> {
    if (
      requestParameters.sessionId === null ||
      requestParameters.sessionId === undefined
    ) {
      throw new runtime.RequiredError(
        "sessionId",
        "Required parameter requestParameters.sessionId was null or undefined when calling enableSessionTan."
      );
    }

    if (
      requestParameters.enableSessionTanParams === null ||
      requestParameters.enableSessionTanParams === undefined
    ) {
      throw new runtime.RequiredError(
        "enableSessionTanParams",
        "Required parameter requestParameters.enableSessionTanParams was null or undefined when calling enableSessionTan."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/{sessionId}/sessiontan`.replace(
          `{${"sessionId"}}`,
          encodeURIComponent(String(requestParameters.sessionId))
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EnableSessionTanParamsToJSON(
          requestParameters.enableSessionTanParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      EnableSessionTanResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async enableSessionTan(
    requestParameters: EnableSessionTanRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<EnableSessionTanResponse> {
    const response = await this.enableSessionTanRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * End Session TAN for the given broker session.  If applicable, the broker may return a message with a confirmation code which can be looked up in the initial activation SMS. If message is present in the response, it should be displayed to the user.
   */
  async endSessionTanRaw(
    requestParameters: EndSessionTanRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<EndSessionTanResponse>> {
    if (
      requestParameters.sessionId === null ||
      requestParameters.sessionId === undefined
    ) {
      throw new runtime.RequiredError(
        "sessionId",
        "Required parameter requestParameters.sessionId was null or undefined when calling endSessionTan."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/{sessionId}/sessiontan`.replace(
          `{${"sessionId"}}`,
          encodeURIComponent(String(requestParameters.sessionId))
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      EndSessionTanResponseFromJSON(jsonValue)
    );
  }

  /**
   * End Session TAN for the given broker session.  If applicable, the broker may return a message with a confirmation code which can be looked up in the initial activation SMS. If message is present in the response, it should be displayed to the user.
   */
  async endSessionTan(
    requestParameters: EndSessionTanRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<EndSessionTanResponse> {
    const response = await this.endSessionTanRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get the status of a decoupled operation.  This is deprecated, use the new `GetDecoupledOperation` instead, which does not require the `sessionId` any more.
   */
  async getDecoupledOperationStatusLegacyRaw(
    requestParameters: GetDecoupledOperationStatusLegacyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<DecoupledOperationStatus>> {
    if (
      requestParameters.sessionId === null ||
      requestParameters.sessionId === undefined
    ) {
      throw new runtime.RequiredError(
        "sessionId",
        "Required parameter requestParameters.sessionId was null or undefined when calling getDecoupledOperationStatusLegacy."
      );
    }

    if (
      requestParameters.decoupledOperationId === null ||
      requestParameters.decoupledOperationId === undefined
    ) {
      throw new runtime.RequiredError(
        "decoupledOperationId",
        "Required parameter requestParameters.decoupledOperationId was null or undefined when calling getDecoupledOperationStatusLegacy."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/{sessionId}/decoupledOperation/{decoupledOperationId}`
          .replace(
            `{${"sessionId"}}`,
            encodeURIComponent(String(requestParameters.sessionId))
          )
          .replace(
            `{${"decoupledOperationId"}}`,
            encodeURIComponent(String(requestParameters.decoupledOperationId))
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DecoupledOperationStatusFromJSON(jsonValue)
    );
  }

  /**
   * Get the status of a decoupled operation.  This is deprecated, use the new `GetDecoupledOperation` instead, which does not require the `sessionId` any more.
   */
  async getDecoupledOperationStatusLegacy(
    requestParameters: GetDecoupledOperationStatusLegacyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<DecoupledOperationStatus> {
    const response = await this.getDecoupledOperationStatusLegacyRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get the currently active broker sessions of the user\'s account.
   */
  async getSessionsRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<SessionResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SessionResponseFromJSON(jsonValue)
    );
  }

  /**
   * Get the currently active broker sessions of the user\'s account.
   */
  async getSessions(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<SessionResponse> {
    const response = await this.getSessionsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Log out from the given broker session.
   */
  async logoutSessionRaw(
    requestParameters: LogoutSessionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<LogoutOkResponseBody>> {
    if (
      requestParameters.sessionId === null ||
      requestParameters.sessionId === undefined
    ) {
      throw new runtime.RequiredError(
        "sessionId",
        "Required parameter requestParameters.sessionId was null or undefined when calling logoutSession."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/{sessionId}`.replace(
          `{${"sessionId"}}`,
          encodeURIComponent(String(requestParameters.sessionId))
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LogoutOkResponseBodyFromJSON(jsonValue)
    );
  }

  /**
   * Log out from the given broker session.
   */
  async logoutSession(
    requestParameters: LogoutSessionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<LogoutOkResponseBody> {
    const response = await this.logoutSessionRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * For brokers with `isOAuth`, sessions can not be created using `AddSession`. This is how a session can be added for an OAuth-based login process:  1. use `prepareOAuthRedirect` to obtain a URL to redirect to. You can provide a `returnTo` URL which will be redirected to later. Note that a list of allowed URLs has to be configured for the client. 2. redirect the user\'s browser to the `redirectTo` URL 3. after the user has logged in at the broker\'s interface, a redirect to `returnTo` with the URL query parameters `verifysession=1`, `code` and `ticketId` will happen 4. the `returnTo` page must call `confirmOAuth` with the given `ticketId` and `code` to finally add the session to the user\'s account
   */
  async prepareOAuthRedirectRaw(
    requestParameters: PrepareOAuthRedirectRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<PrepareOAuthRedirectResponse>> {
    if (
      requestParameters.prepareOAuthRedirectParams === null ||
      requestParameters.prepareOAuthRedirectParams === undefined
    ) {
      throw new runtime.RequiredError(
        "prepareOAuthRedirectParams",
        "Required parameter requestParameters.prepareOAuthRedirectParams was null or undefined when calling prepareOAuthRedirect."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/prepareOAuthRedirect`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PrepareOAuthRedirectParamsToJSON(
          requestParameters.prepareOAuthRedirectParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PrepareOAuthRedirectResponseFromJSON(jsonValue)
    );
  }

  /**
   * For brokers with `isOAuth`, sessions can not be created using `AddSession`. This is how a session can be added for an OAuth-based login process:  1. use `prepareOAuthRedirect` to obtain a URL to redirect to. You can provide a `returnTo` URL which will be redirected to later. Note that a list of allowed URLs has to be configured for the client. 2. redirect the user\'s browser to the `redirectTo` URL 3. after the user has logged in at the broker\'s interface, a redirect to `returnTo` with the URL query parameters `verifysession=1`, `code` and `ticketId` will happen 4. the `returnTo` page must call `confirmOAuth` with the given `ticketId` and `code` to finally add the session to the user\'s account
   */
  async prepareOAuthRedirect(
    requestParameters: PrepareOAuthRedirectRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<PrepareOAuthRedirectResponse> {
    const response = await this.prepareOAuthRedirectRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Trigger a background sync process for the given broker session. This means that a sync will be scheduled as soon as possible. All data related to the portfolio (e.g. positions and orders) will be loaded into the brokerize database.
   */
  async triggerSessionSyncRaw(
    requestParameters: TriggerSessionSyncRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<OkResponseBody>> {
    if (
      requestParameters.sessionId === null ||
      requestParameters.sessionId === undefined
    ) {
      throw new runtime.RequiredError(
        "sessionId",
        "Required parameter requestParameters.sessionId was null or undefined when calling triggerSessionSync."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/sessions/{sessionId}/sync`.replace(
          `{${"sessionId"}}`,
          encodeURIComponent(String(requestParameters.sessionId))
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OkResponseBodyFromJSON(jsonValue)
    );
  }

  /**
   * Trigger a background sync process for the given broker session. This means that a sync will be scheduled as soon as possible. All data related to the portfolio (e.g. positions and orders) will be loaded into the brokerize database.
   */
  async triggerSessionSync(
    requestParameters: TriggerSessionSyncRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<OkResponseBody> {
    const response = await this.triggerSessionSyncRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}
