/* tslint:disable */
/* eslint-disable */
/**
 * brokerize
 * The brokerize API allows clients to implement multi-brokerage with a unified interface. For more information, visit brokerize.com
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  AccessTokenResult,
  AccessTokenResultFromJSON,
  AccessTokenResultToJSON,
  CheckRecoveryPhrase200Response,
  CheckRecoveryPhrase200ResponseFromJSON,
  CheckRecoveryPhrase200ResponseToJSON,
  CreateAccessTokenParams,
  CreateAccessTokenParamsFromJSON,
  CreateAccessTokenParamsToJSON,
  CreateGuestUserResponse,
  CreateGuestUserResponseFromJSON,
  CreateGuestUserResponseToJSON,
  CreateRecoveryPhraseParams,
  CreateRecoveryPhraseParamsFromJSON,
  CreateRecoveryPhraseParamsToJSON,
  CreateRecoveryPhraseResult,
  CreateRecoveryPhraseResultFromJSON,
  CreateRecoveryPhraseResultToJSON,
  ErrorResponse,
  ErrorResponseFromJSON,
  ErrorResponseToJSON,
  GetAccessTokensResponse,
  GetAccessTokensResponseFromJSON,
  GetAccessTokensResponseToJSON,
  GetAcessTokenAvailablePermissions200Response,
  GetAcessTokenAvailablePermissions200ResponseFromJSON,
  GetAcessTokenAvailablePermissions200ResponseToJSON,
  GetRecoveryPhrasesResponse,
  GetRecoveryPhrasesResponseFromJSON,
  GetRecoveryPhrasesResponseToJSON,
  GetUserResponse,
  GetUserResponseFromJSON,
  GetUserResponseToJSON,
  ObtainTokenByRecoveryPhraseParams,
  ObtainTokenByRecoveryPhraseParamsFromJSON,
  ObtainTokenByRecoveryPhraseParamsToJSON,
  TokenResponse,
  TokenResponseFromJSON,
  TokenResponseToJSON,
} from "../models";

export interface CheckRecoveryPhraseRequest {
  obtainTokenByRecoveryPhraseParams: ObtainTokenByRecoveryPhraseParams;
}

export interface CreateAccessTokenRequest {
  createAccessTokenParams: CreateAccessTokenParams;
}

export interface CreateRecoveryPhraseRequest {
  createRecoveryPhraseParams: CreateRecoveryPhraseParams;
}

export interface DeleteRecoveryPhraseRequest {
  recoveryPhraseId: string;
}

export interface ObtainTokenRequest {
  grantType: string;
  refreshToken: string;
}

export interface ObtainTokenByRecoveryPhraseRequest {
  obtainTokenByRecoveryPhraseParams: ObtainTokenByRecoveryPhraseParams;
}

export interface RevokeAccessTokenRequest {
  accessTokenId: string;
}

/**
 *
 */
export class UserApi extends runtime.BaseAPI {
  /**
   * Check if the RecoveryPhrase is still valid without obtaining a new token set. This can be used in frontends when users are asked if they still have their RecoveryPhrase.
   */
  async checkRecoveryPhraseRaw(
    requestParameters: CheckRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<CheckRecoveryPhrase200Response>> {
    if (
      requestParameters.obtainTokenByRecoveryPhraseParams === null ||
      requestParameters.obtainTokenByRecoveryPhraseParams === undefined
    ) {
      throw new runtime.RequiredError(
        "obtainTokenByRecoveryPhraseParams",
        "Required parameter requestParameters.obtainTokenByRecoveryPhraseParams was null or undefined when calling checkRecoveryPhrase."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    const response = await this.request(
      {
        path: `/user/recoveryPhrases/check`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ObtainTokenByRecoveryPhraseParamsToJSON(
          requestParameters.obtainTokenByRecoveryPhraseParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CheckRecoveryPhrase200ResponseFromJSON(jsonValue)
    );
  }

  /**
   * Check if the RecoveryPhrase is still valid without obtaining a new token set. This can be used in frontends when users are asked if they still have their RecoveryPhrase.
   */
  async checkRecoveryPhrase(
    requestParameters: CheckRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<CheckRecoveryPhrase200Response> {
    const response = await this.checkRecoveryPhraseRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a token for the current user. The token can be used to access resources on behalf of the user.
   */
  async createAccessTokenRaw(
    requestParameters: CreateAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<AccessTokenResult>> {
    if (
      requestParameters.createAccessTokenParams === null ||
      requestParameters.createAccessTokenParams === undefined
    ) {
      throw new runtime.RequiredError(
        "createAccessTokenParams",
        "Required parameter requestParameters.createAccessTokenParams was null or undefined when calling createAccessToken."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/accessTokens`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateAccessTokenParamsToJSON(
          requestParameters.createAccessTokenParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AccessTokenResultFromJSON(jsonValue)
    );
  }

  /**
   * Create a token for the current user. The token can be used to access resources on behalf of the user.
   */
  async createAccessToken(
    requestParameters: CreateAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<AccessTokenResult> {
    const response = await this.createAccessTokenRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a guest user and return a token which can be used to access resources.  The lifetime of the generated temporary user as well as the returned `access_token` depend on the client configuration. It is usually around 24 hours. For some clients, tokens can be expired earlier based on inactivity.  If the client has configured a longer lifetime for their guest users, a `refresh_token`  is included in the response. This token can be used to renew the `access_token` after it has expired.  The `refresh_token` can be used to obtain a new `access_token` after the original token has expired using the `/user/token` endpoint.
   */
  async createGuestUserRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<CreateGuestUserResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    const response = await this.request(
      {
        path: `/user/guest`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CreateGuestUserResponseFromJSON(jsonValue)
    );
  }

  /**
   * Create a guest user and return a token which can be used to access resources.  The lifetime of the generated temporary user as well as the returned `access_token` depend on the client configuration. It is usually around 24 hours. For some clients, tokens can be expired earlier based on inactivity.  If the client has configured a longer lifetime for their guest users, a `refresh_token`  is included in the response. This token can be used to renew the `access_token` after it has expired.  The `refresh_token` can be used to obtain a new `access_token` after the original token has expired using the `/user/token` endpoint.
   */
  async createGuestUser(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<CreateGuestUserResponse> {
    const response = await this.createGuestUserRaw(initOverrides);
    return await response.value();
  }

  /**
   * Create a RecoveryPhrase for the current guest user.  The brokerize backend uses RecoveryPhrases instead of email + password registration or similar approaches, which can never be guaranteed to be anonymous.  Users can simply generate a RecoveryPhrase and save it in a password manager, memorize it or write it down in a safe location.  The BIP39 word list known from Bitcoins is used to encode a cryptographically safe random token and allows access to the account later (see endpoint `ObtainTokenFromRecoveryPhrase`).
   */
  async createRecoveryPhraseRaw(
    requestParameters: CreateRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<CreateRecoveryPhraseResult>> {
    if (
      requestParameters.createRecoveryPhraseParams === null ||
      requestParameters.createRecoveryPhraseParams === undefined
    ) {
      throw new runtime.RequiredError(
        "createRecoveryPhraseParams",
        "Required parameter requestParameters.createRecoveryPhraseParams was null or undefined when calling createRecoveryPhrase."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/recoveryPhrases`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateRecoveryPhraseParamsToJSON(
          requestParameters.createRecoveryPhraseParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CreateRecoveryPhraseResultFromJSON(jsonValue)
    );
  }

  /**
   * Create a RecoveryPhrase for the current guest user.  The brokerize backend uses RecoveryPhrases instead of email + password registration or similar approaches, which can never be guaranteed to be anonymous.  Users can simply generate a RecoveryPhrase and save it in a password manager, memorize it or write it down in a safe location.  The BIP39 word list known from Bitcoins is used to encode a cryptographically safe random token and allows access to the account later (see endpoint `ObtainTokenFromRecoveryPhrase`).
   */
  async createRecoveryPhrase(
    requestParameters: CreateRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<CreateRecoveryPhraseResult> {
    const response = await this.createRecoveryPhraseRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Delete the current user (only allowed if it is a guest account). Also logs out all active broker sessions attached to the user.
   */
  async deleteGuestUserRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user`,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete the current user (only allowed if it is a guest account). Also logs out all active broker sessions attached to the user.
   */
  async deleteGuestUser(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<void> {
    await this.deleteGuestUserRaw(initOverrides);
  }

  /**
   * Delete the RecoveryPhrase from the account.
   */
  async deleteRecoveryPhraseRaw(
    requestParameters: DeleteRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.recoveryPhraseId === null ||
      requestParameters.recoveryPhraseId === undefined
    ) {
      throw new runtime.RequiredError(
        "recoveryPhraseId",
        "Required parameter requestParameters.recoveryPhraseId was null or undefined when calling deleteRecoveryPhrase."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/recoveryPhrases/{recoveryPhraseId}`.replace(
          `{${"recoveryPhraseId"}}`,
          encodeURIComponent(String(requestParameters.recoveryPhraseId))
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete the RecoveryPhrase from the account.
   */
  async deleteRecoveryPhrase(
    requestParameters: DeleteRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<void> {
    await this.deleteRecoveryPhraseRaw(requestParameters, initOverrides);
  }

  /**
   */
  async getAccessTokensRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetAccessTokensResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/accessTokens`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetAccessTokensResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async getAccessTokens(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetAccessTokensResponse> {
    const response = await this.getAccessTokensRaw(initOverrides);
    return await response.value();
  }

  /**
   * Figure out which permissions are available to select from for a new access token.
   */
  async getAcessTokenAvailablePermissionsRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<
    runtime.ApiResponse<GetAcessTokenAvailablePermissions200Response>
  > {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/accessTokenAvailablePermissions`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetAcessTokenAvailablePermissions200ResponseFromJSON(jsonValue)
    );
  }

  /**
   * Figure out which permissions are available to select from for a new access token.
   */
  async getAcessTokenAvailablePermissions(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetAcessTokenAvailablePermissions200Response> {
    const response = await this.getAcessTokenAvailablePermissionsRaw(
      initOverrides
    );
    return await response.value();
  }

  /**
   * Lists all the recoveryPhrases metadata the user has in their account.
   */
  async getRecoveryPhrasesRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetRecoveryPhrasesResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/recoveryPhrases`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetRecoveryPhrasesResponseFromJSON(jsonValue)
    );
  }

  /**
   * Lists all the recoveryPhrases metadata the user has in their account.
   */
  async getRecoveryPhrases(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetRecoveryPhrasesResponse> {
    const response = await this.getRecoveryPhrasesRaw(initOverrides);
    return await response.value();
  }

  /**
   * Checks the provided authentication and returns the logged-in user.
   */
  async getUserRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetUserResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetUserResponseFromJSON(jsonValue)
    );
  }

  /**
   * Checks the provided authentication and returns the logged-in user.
   */
  async getUser(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetUserResponse> {
    const response = await this.getUserRaw(initOverrides);
    return await response.value();
  }

  /**
   * Obtain a new access token using a refresh token as specified in https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.4. If `CreateGuestUser` has provided a `refresh_token`, this endpoint may be used to obtain a new `access_token` after the original token has expired.
   */
  async obtainTokenRaw(
    requestParameters: ObtainTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<TokenResponse>> {
    if (
      requestParameters.grantType === null ||
      requestParameters.grantType === undefined
    ) {
      throw new runtime.RequiredError(
        "grantType",
        "Required parameter requestParameters.grantType was null or undefined when calling obtainToken."
      );
    }

    if (
      requestParameters.refreshToken === null ||
      requestParameters.refreshToken === undefined
    ) {
      throw new runtime.RequiredError(
        "refreshToken",
        "Required parameter requestParameters.refreshToken was null or undefined when calling obtainToken."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      throw new Error(
        "URLSearchParams support has been dopped due to compatibility problems in mobile apps."
      );
    }

    if (requestParameters.grantType !== undefined) {
      formParams.append("grant_type", requestParameters.grantType as any);
    }

    if (requestParameters.refreshToken !== undefined) {
      formParams.append("refresh_token", requestParameters.refreshToken as any);
    }

    const response = await this.request(
      {
        path: `/user/token`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      TokenResponseFromJSON(jsonValue)
    );
  }

  /**
   * Obtain a new access token using a refresh token as specified in https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.4. If `CreateGuestUser` has provided a `refresh_token`, this endpoint may be used to obtain a new `access_token` after the original token has expired.
   */
  async obtainToken(
    requestParameters: ObtainTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<TokenResponse> {
    const response = await this.obtainTokenRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Obtain a new access and refresh token set by a RecoveryPhrase. The new set also contains a refresh_token etc, so it can then be used just like the tokens obtained from the `ObtainToken` endpoint.  This also creates a new `trading_session`, as RecoveryPhrases never allow access to an existing trading_session.
   */
  async obtainTokenByRecoveryPhraseRaw(
    requestParameters: ObtainTokenByRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<TokenResponse>> {
    if (
      requestParameters.obtainTokenByRecoveryPhraseParams === null ||
      requestParameters.obtainTokenByRecoveryPhraseParams === undefined
    ) {
      throw new runtime.RequiredError(
        "obtainTokenByRecoveryPhraseParams",
        "Required parameter requestParameters.obtainTokenByRecoveryPhraseParams was null or undefined when calling obtainTokenByRecoveryPhrase."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    const response = await this.request(
      {
        path: `/user/recoveryPhrases/token`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ObtainTokenByRecoveryPhraseParamsToJSON(
          requestParameters.obtainTokenByRecoveryPhraseParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      TokenResponseFromJSON(jsonValue)
    );
  }

  /**
   * Obtain a new access and refresh token set by a RecoveryPhrase. The new set also contains a refresh_token etc, so it can then be used just like the tokens obtained from the `ObtainToken` endpoint.  This also creates a new `trading_session`, as RecoveryPhrases never allow access to an existing trading_session.
   */
  async obtainTokenByRecoveryPhrase(
    requestParameters: ObtainTokenByRecoveryPhraseRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<TokenResponse> {
    const response = await this.obtainTokenByRecoveryPhraseRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async revokeAccessTokenRaw(
    requestParameters: RevokeAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.accessTokenId === null ||
      requestParameters.accessTokenId === undefined
    ) {
      throw new runtime.RequiredError(
        "accessTokenId",
        "Required parameter requestParameters.accessTokenId was null or undefined when calling revokeAccessToken."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/accessTokens/{accessTokenId}`.replace(
          `{${"accessTokenId"}}`,
          encodeURIComponent(String(requestParameters.accessTokenId))
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async revokeAccessToken(
    requestParameters: RevokeAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<void> {
    await this.revokeAccessTokenRaw(requestParameters, initOverrides);
  }
}
