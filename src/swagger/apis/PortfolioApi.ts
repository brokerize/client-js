/* tslint:disable */
/* eslint-disable */
/**
 * brokerize
 * The brokerize API allows clients to implement multi-brokerage with a unified interface. For more information, visit brokerize.com
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  ErrorResponse,
  ErrorResponseFromJSON,
  ErrorResponseToJSON,
  GetAuthInfoResponse,
  GetAuthInfoResponseFromJSON,
  GetAuthInfoResponseToJSON,
  GetPortfolioCalendarResponse,
  GetPortfolioCalendarResponseFromJSON,
  GetPortfolioCalendarResponseToJSON,
  GetPortfolioOrdersResponse,
  GetPortfolioOrdersResponseFromJSON,
  GetPortfolioOrdersResponseToJSON,
  GetPortfolioPositionsResponse,
  GetPortfolioPositionsResponseFromJSON,
  GetPortfolioPositionsResponseToJSON,
  GetPortfolioQuotesResponse,
  GetPortfolioQuotesResponseFromJSON,
  GetPortfolioQuotesResponseToJSON,
  GetPortfolioTradeStatisticsResponse,
  GetPortfolioTradeStatisticsResponseFromJSON,
  GetPortfolioTradeStatisticsResponseToJSON,
  GetPortfolioTradesResponse,
  GetPortfolioTradesResponseFromJSON,
  GetPortfolioTradesResponseToJSON,
  OkResponseBody,
  OkResponseBodyFromJSON,
  OkResponseBodyToJSON,
  PortfoliosResponse,
  PortfoliosResponseFromJSON,
  PortfoliosResponseToJSON,
  RenamePortfolioRequest,
  RenamePortfolioRequestFromJSON,
  RenamePortfolioRequestToJSON,
  TradeWarning,
  TradeWarningFromJSON,
  TradeWarningToJSON,
} from "../models";

export interface DeletePortfolioRequest {
  portfolioId: string;
}

export interface GetAuthInfoRequest {
  portfolioId: string;
}

export interface GetPortfolioCalendarRequest {
  portfolioId: string;
  dateRanges: string;
}

export interface GetPortfolioOrdersRequest {
  portfolioId: string;
  take?: number;
  skip?: number;
  search?: string;
  statuses?: string;
  orderBy?: string;
  isin?: string;
  wkn?: string;
  sinoTicker?: string;
  usTicker?: string;
  cryptoCode?: string;
}

export interface GetPortfolioPositionsRequest {
  portfolioId: string;
}

export interface GetPortfolioQuotesRequest {
  portfolioId: string;
}

export interface GetPortfolioTradeStatisticsRequest {
  portfolioId: string;
  dateRanges: string;
}

export interface GetPortfolioTradeWarningsRequest {
  portfolioId: string;
}

export interface GetPortfolioTradesRequest {
  portfolioId: string;
  search?: string;
  take?: number;
  skip?: number;
}

export interface RenamePortfolioOperationRequest {
  portfolioId: string;
  renamePortfolioRequest: RenamePortfolioRequest;
}

/**
 *
 */
export class PortfolioApi extends runtime.BaseAPI {
  /**
   */
  async deletePortfolioRaw(
    requestParameters: DeletePortfolioRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<OkResponseBody>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling deletePortfolio."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OkResponseBodyFromJSON(jsonValue)
    );
  }

  /**
   */
  async deletePortfolio(
    requestParameters: DeletePortfolioRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<OkResponseBody> {
    const response = await this.deletePortfolioRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get the AuthInfo for the given portfolio.  If the portfolio does not have an online session, this will return a 400 status code.  If it does, the response describes whether session TAN is available or active and which auth methods are available for the given portfolio (this information depends on the broker and the user\'s account settings).  The response determines which of the following operations can be used and which are required to successfully perform an operation in a portfolio:  -   Session TAN handling (for performing other actions in portfolios without further per-case authorization)     -   [CreateSessionTanChallenge](#operation/CreateSessionTanChallenge) to request a challenge for s TAN activation.     -   [EnableSessionTan](#operation/EnableSessionTan) to enable the session TAN.     -   [EndSessionTan](#operation/EndSessionTan) to end the session TAN. -   Create a trade     -   [PrepareTrade](#operation/PrepareTrade) to figure out how a given security can be traded in a portfolio.     -   [CreateTradeChallenge](#operation/CreateTradeChallenge) to (for example) request a TAN for a trade.     -   [CreateTrade](#operation/CreateTrade) to perform the trade. -   Edit an order     -   [CreateChangeOrderChallenge](#operation/CreateChangeOrderChallenge) to request a challenge for an order change.     -   [ChangeOrder](#operation/ChangeOrder) to change an order. -   Cancel an order     -   [CreateCancelOrderChallenge](#operation/CreateCancelOrderChallenge) to request a Challenge for an order cancellation.     -   [CancelOrder](#operation/CancelOrder) to cancel an order.  The list of available AuthMethods should only be presented to the user if session TAN is not active (yet). The list and names are defined by our partner brokers. All auth methods are generally categorized using the `flow` attribute:  | `flow`               | requires challenge? | Description                                                                                                                                                                                                          | | -------------------- | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `TAN`                | no                  | the simplest flow: no challenge is required to perform the operation. the TAN is simply sent as parameter `tan`                                                                              | | `CHALLENGE_RESPONSE` | yes                 | a challenge must be created using the `createXYZChallenge` operations and the challenge must be presented to the user. The user can then execute the action using the `challengeId` and `challengeResponse` parameters. If the auth method has `challengeResponseIsOnlyConfirmation=true`, that challengeResponse is always an empty string and users do not enter a TAN. Otherwise, a text field labelled with `tanFieldLabel` must be displayed where the user enteirs their challengeResponse. | | `DECOUPLED`          | no                  | the operation is executed without any TAN, but returns a `decoupledOperationId` which can be used to read the action\'s status. Users will authorize the action in another frontend (usually in their broker\'s app). Note that currently `DECOUPLED` auth methods only work for enabling session TAN.   |  - If `sessionTanActive` is `true`: Session TAN has been enabled for the session that currently backs the portfolio. In this case, all operations like `CreateTrade` can be executed right away without an `authMethod`. The UI should *not* show a dropdown with the auth methods in this case. - If `sessionTanActive` is `false` but `sessionTanSupported` is `true`: the user can enable session TAN using `CreateSessionTanChallenge` / `EnableSessionTan`. - If `allOperationsRequireSessionTan` is `true`, the auth methods can *ONLY* be used for enabling session TAN. - Otherwise, the `authMethods` can be used to perform individual operations.  | sessionTanActive | sessionTanSupported | allOperationsRequireSessionTan | Description                                                                                                                                                                                                                                                 | | ---------------- | ------------------- | ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `true`           | `true`              | -                              | Session TAN has been enabled for the session that currently backs the portfolio. In this case, all operations like `CreateTrade`, `ChangeOrder`, `CancelOrder` can be executed right away without an `authMethod`. The UI should _not_ show a dropdown with the auth methods in this case. | | `false`          | `true`              | `true`                         | the user can enable session TAN using the provided auth methods via `CreateSessionTanChallenge` / `EnableSessionTan`. All other operations can only take place after session TAN has been enabled.                                                          | | `false`          | `true`              | `false`                        | the user can enable any operation (enable session tan, create trade, cancel order, change order) using the provided auth methods                                                                                                                            |  Note that it is possible that brokers only reveal all details about the available auth methods *TOGETHER* with the first `GetChallenge` request. This special behavior can be simulated with our demo broker when the flag `lazyAuthMethods=true` is specified upon creation of a demo account. In those accounts, the `GetAuthInfo` endpoint will initially return a single \"placeholder\" method with `{flow: \"CHALLENGE_RESPONSE\", isDefaultMethod: true, ...}`.  In the situation where there is *exactly one* auth method like this, frontends may immediately request the challenge for the desired operation without waiting for the user to click the get challenge button (for Session TAN, this means that as soon as the user opens the dialog for enabling session TAN, `CreateSessionTanChallenge` can be called). In the case described here, `AuthInfo` will be populated with the actual list of auth methods when the create challenge request returns (also, the corresponding WebSocket event is published to notify about this change). `GetAuthInfo` must be called again in this case and repopulate the corresponding frontend (e.g. the name of the auth method will become available etc.). So what is done in this case is: request a challenge for the *unknown* default method in order to get both a challenge and an update of the auth methods.  Note that usually challenges have effects like an SMS or some broker app notification for the end user, so it is important to keep the requested challenge info, *even when auth info is refreshed*. For example, if there is a select box with the auth method list, that box must keep its selected `id` while updating the now-available `label`. This way, the user can use the first requested challenge, as the frontend will still be in the right state.
   */
  async getAuthInfoRaw(
    requestParameters: GetAuthInfoRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetAuthInfoResponse>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getAuthInfo."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/authinfo`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetAuthInfoResponseFromJSON(jsonValue)
    );
  }

  /**
   * Get the AuthInfo for the given portfolio.  If the portfolio does not have an online session, this will return a 400 status code.  If it does, the response describes whether session TAN is available or active and which auth methods are available for the given portfolio (this information depends on the broker and the user\'s account settings).  The response determines which of the following operations can be used and which are required to successfully perform an operation in a portfolio:  -   Session TAN handling (for performing other actions in portfolios without further per-case authorization)     -   [CreateSessionTanChallenge](#operation/CreateSessionTanChallenge) to request a challenge for s TAN activation.     -   [EnableSessionTan](#operation/EnableSessionTan) to enable the session TAN.     -   [EndSessionTan](#operation/EndSessionTan) to end the session TAN. -   Create a trade     -   [PrepareTrade](#operation/PrepareTrade) to figure out how a given security can be traded in a portfolio.     -   [CreateTradeChallenge](#operation/CreateTradeChallenge) to (for example) request a TAN for a trade.     -   [CreateTrade](#operation/CreateTrade) to perform the trade. -   Edit an order     -   [CreateChangeOrderChallenge](#operation/CreateChangeOrderChallenge) to request a challenge for an order change.     -   [ChangeOrder](#operation/ChangeOrder) to change an order. -   Cancel an order     -   [CreateCancelOrderChallenge](#operation/CreateCancelOrderChallenge) to request a Challenge for an order cancellation.     -   [CancelOrder](#operation/CancelOrder) to cancel an order.  The list of available AuthMethods should only be presented to the user if session TAN is not active (yet). The list and names are defined by our partner brokers. All auth methods are generally categorized using the `flow` attribute:  | `flow`               | requires challenge? | Description                                                                                                                                                                                                          | | -------------------- | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `TAN`                | no                  | the simplest flow: no challenge is required to perform the operation. the TAN is simply sent as parameter `tan`                                                                              | | `CHALLENGE_RESPONSE` | yes                 | a challenge must be created using the `createXYZChallenge` operations and the challenge must be presented to the user. The user can then execute the action using the `challengeId` and `challengeResponse` parameters. If the auth method has `challengeResponseIsOnlyConfirmation=true`, that challengeResponse is always an empty string and users do not enter a TAN. Otherwise, a text field labelled with `tanFieldLabel` must be displayed where the user enteirs their challengeResponse. | | `DECOUPLED`          | no                  | the operation is executed without any TAN, but returns a `decoupledOperationId` which can be used to read the action\'s status. Users will authorize the action in another frontend (usually in their broker\'s app). Note that currently `DECOUPLED` auth methods only work for enabling session TAN.   |  - If `sessionTanActive` is `true`: Session TAN has been enabled for the session that currently backs the portfolio. In this case, all operations like `CreateTrade` can be executed right away without an `authMethod`. The UI should *not* show a dropdown with the auth methods in this case. - If `sessionTanActive` is `false` but `sessionTanSupported` is `true`: the user can enable session TAN using `CreateSessionTanChallenge` / `EnableSessionTan`. - If `allOperationsRequireSessionTan` is `true`, the auth methods can *ONLY* be used for enabling session TAN. - Otherwise, the `authMethods` can be used to perform individual operations.  | sessionTanActive | sessionTanSupported | allOperationsRequireSessionTan | Description                                                                                                                                                                                                                                                 | | ---------------- | ------------------- | ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `true`           | `true`              | -                              | Session TAN has been enabled for the session that currently backs the portfolio. In this case, all operations like `CreateTrade`, `ChangeOrder`, `CancelOrder` can be executed right away without an `authMethod`. The UI should _not_ show a dropdown with the auth methods in this case. | | `false`          | `true`              | `true`                         | the user can enable session TAN using the provided auth methods via `CreateSessionTanChallenge` / `EnableSessionTan`. All other operations can only take place after session TAN has been enabled.                                                          | | `false`          | `true`              | `false`                        | the user can enable any operation (enable session tan, create trade, cancel order, change order) using the provided auth methods                                                                                                                            |  Note that it is possible that brokers only reveal all details about the available auth methods *TOGETHER* with the first `GetChallenge` request. This special behavior can be simulated with our demo broker when the flag `lazyAuthMethods=true` is specified upon creation of a demo account. In those accounts, the `GetAuthInfo` endpoint will initially return a single \"placeholder\" method with `{flow: \"CHALLENGE_RESPONSE\", isDefaultMethod: true, ...}`.  In the situation where there is *exactly one* auth method like this, frontends may immediately request the challenge for the desired operation without waiting for the user to click the get challenge button (for Session TAN, this means that as soon as the user opens the dialog for enabling session TAN, `CreateSessionTanChallenge` can be called). In the case described here, `AuthInfo` will be populated with the actual list of auth methods when the create challenge request returns (also, the corresponding WebSocket event is published to notify about this change). `GetAuthInfo` must be called again in this case and repopulate the corresponding frontend (e.g. the name of the auth method will become available etc.). So what is done in this case is: request a challenge for the *unknown* default method in order to get both a challenge and an update of the auth methods.  Note that usually challenges have effects like an SMS or some broker app notification for the end user, so it is important to keep the requested challenge info, *even when auth info is refreshed*. For example, if there is a select box with the auth method list, that box must keep its selected `id` while updating the now-available `label`. This way, the user can use the first requested challenge, as the frontend will still be in the right state.
   */
  async getAuthInfo(
    requestParameters: GetAuthInfoRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetAuthInfoResponse> {
    const response = await this.getAuthInfoRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Retrieve \"by-day\" aggregated values for the selected date ranges.
   */
  async getPortfolioCalendarRaw(
    requestParameters: GetPortfolioCalendarRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetPortfolioCalendarResponse>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getPortfolioCalendar."
      );
    }

    if (
      requestParameters.dateRanges === null ||
      requestParameters.dateRanges === undefined
    ) {
      throw new runtime.RequiredError(
        "dateRanges",
        "Required parameter requestParameters.dateRanges was null or undefined when calling getPortfolioCalendar."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.dateRanges !== undefined) {
      queryParameters["dateRanges"] = requestParameters.dateRanges;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/calendar`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetPortfolioCalendarResponseFromJSON(jsonValue)
    );
  }

  /**
   * Retrieve \"by-day\" aggregated values for the selected date ranges.
   */
  async getPortfolioCalendar(
    requestParameters: GetPortfolioCalendarRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetPortfolioCalendarResponse> {
    const response = await this.getPortfolioCalendarRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async getPortfolioOrdersRaw(
    requestParameters: GetPortfolioOrdersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetPortfolioOrdersResponse>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getPortfolioOrders."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.take !== undefined) {
      queryParameters["take"] = requestParameters.take;
    }

    if (requestParameters.skip !== undefined) {
      queryParameters["skip"] = requestParameters.skip;
    }

    if (requestParameters.search !== undefined) {
      queryParameters["search"] = requestParameters.search;
    }

    if (requestParameters.statuses !== undefined) {
      queryParameters["statuses"] = requestParameters.statuses;
    }

    if (requestParameters.orderBy !== undefined) {
      queryParameters["orderBy"] = requestParameters.orderBy;
    }

    if (requestParameters.isin !== undefined) {
      queryParameters["isin"] = requestParameters.isin;
    }

    if (requestParameters.wkn !== undefined) {
      queryParameters["wkn"] = requestParameters.wkn;
    }

    if (requestParameters.sinoTicker !== undefined) {
      queryParameters["sinoTicker"] = requestParameters.sinoTicker;
    }

    if (requestParameters.usTicker !== undefined) {
      queryParameters["usTicker"] = requestParameters.usTicker;
    }

    if (requestParameters.cryptoCode !== undefined) {
      queryParameters["cryptoCode"] = requestParameters.cryptoCode;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/orders`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetPortfolioOrdersResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async getPortfolioOrders(
    requestParameters: GetPortfolioOrdersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetPortfolioOrdersResponse> {
    const response = await this.getPortfolioOrdersRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async getPortfolioPositionsRaw(
    requestParameters: GetPortfolioPositionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetPortfolioPositionsResponse>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getPortfolioPositions."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/positions`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetPortfolioPositionsResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async getPortfolioPositions(
    requestParameters: GetPortfolioPositionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetPortfolioPositionsResponse> {
    const response = await this.getPortfolioPositionsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async getPortfolioQuotesRaw(
    requestParameters: GetPortfolioQuotesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetPortfolioQuotesResponse>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getPortfolioQuotes."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/quotes`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetPortfolioQuotesResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async getPortfolioQuotes(
    requestParameters: GetPortfolioQuotesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetPortfolioQuotesResponse> {
    const response = await this.getPortfolioQuotesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Load statistics based on the trade list for selected date ranges. The statistics (such as `longestWinningStreak` or `tradeCount`) are computed for each of the requested date ranges.
   */
  async getPortfolioTradeStatisticsRaw(
    requestParameters: GetPortfolioTradeStatisticsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetPortfolioTradeStatisticsResponse>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getPortfolioTradeStatistics."
      );
    }

    if (
      requestParameters.dateRanges === null ||
      requestParameters.dateRanges === undefined
    ) {
      throw new runtime.RequiredError(
        "dateRanges",
        "Required parameter requestParameters.dateRanges was null or undefined when calling getPortfolioTradeStatistics."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.dateRanges !== undefined) {
      queryParameters["dateRanges"] = requestParameters.dateRanges;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/trades/statistics`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetPortfolioTradeStatisticsResponseFromJSON(jsonValue)
    );
  }

  /**
   * Load statistics based on the trade list for selected date ranges. The statistics (such as `longestWinningStreak` or `tradeCount`) are computed for each of the requested date ranges.
   */
  async getPortfolioTradeStatistics(
    requestParameters: GetPortfolioTradeStatisticsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetPortfolioTradeStatisticsResponse> {
    const response = await this.getPortfolioTradeStatisticsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async getPortfolioTradeWarningsRaw(
    requestParameters: GetPortfolioTradeWarningsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<Array<TradeWarning>>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getPortfolioTradeWarnings."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/trades/warnings`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(TradeWarningFromJSON)
    );
  }

  /**
   */
  async getPortfolioTradeWarnings(
    requestParameters: GetPortfolioTradeWarningsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<Array<TradeWarning>> {
    const response = await this.getPortfolioTradeWarningsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Load a list of completed trades in a portfolio. A completed trade corresponds to *one* closing of a position. Technically each closing of a position corresponds to one execution of an order with `intent=close` (usually those are sell orders, but in the case of short selling, opening a position is a sell order with intent=open).  The analysis follows the FIFO (First In, First Out) principle to accurately summarize trades. Each time a position is closed (note that partial executions are possible. In this case, each individual execution is regarded as a transaction), the system identifies the earliest corresponding \"open position execution\" that contributed to that closing. The result includes a single entry for each closing transaction, detailing key metrics such as profit/loss and holding period, based on the matched opening transactions.  This could be a real world example: - 2020-01-01: buy 5 stock1 for 100 USD each - 2021-06-01: buy 3 stock1 for 200 USD each - 2021-06-06: sell 6 stock1 for 300 USD each  In this case, the result would be one completed trade (corresponding to the last sell) with a profit of `(300*6)-(100*5+1*200)=1800-700=1100 USD`. There is an open position remaining (2 units of stock1, which correspond to the second buy transaction).  When we add this sell: - 2021-06-07: sell 2 stock1 for 400 USD each  It would add a second complete trade with a profit of `(400*2)-(200*2)=800-400=400 USD`.  For some brokers, the order history may be incomplete (e.g. only reveals the latest 90 days), so that we do not know if there could be older transactions. Thus, our implementation might detect (given the current set of open positions together with the list of order executions) that we cannot figure out the corresponding opening transactions for a closing transaction. Affected trades will be ignored for this analysis and might appear as warning items in the `/warnings` endpoint. Frontends should show those warnings so that users can understand why the analysis is incomplete.
   */
  async getPortfolioTradesRaw(
    requestParameters: GetPortfolioTradesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<GetPortfolioTradesResponse>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling getPortfolioTrades."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.search !== undefined) {
      queryParameters["search"] = requestParameters.search;
    }

    if (requestParameters.take !== undefined) {
      queryParameters["take"] = requestParameters.take;
    }

    if (requestParameters.skip !== undefined) {
      queryParameters["skip"] = requestParameters.skip;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/trades`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetPortfolioTradesResponseFromJSON(jsonValue)
    );
  }

  /**
   * Load a list of completed trades in a portfolio. A completed trade corresponds to *one* closing of a position. Technically each closing of a position corresponds to one execution of an order with `intent=close` (usually those are sell orders, but in the case of short selling, opening a position is a sell order with intent=open).  The analysis follows the FIFO (First In, First Out) principle to accurately summarize trades. Each time a position is closed (note that partial executions are possible. In this case, each individual execution is regarded as a transaction), the system identifies the earliest corresponding \"open position execution\" that contributed to that closing. The result includes a single entry for each closing transaction, detailing key metrics such as profit/loss and holding period, based on the matched opening transactions.  This could be a real world example: - 2020-01-01: buy 5 stock1 for 100 USD each - 2021-06-01: buy 3 stock1 for 200 USD each - 2021-06-06: sell 6 stock1 for 300 USD each  In this case, the result would be one completed trade (corresponding to the last sell) with a profit of `(300*6)-(100*5+1*200)=1800-700=1100 USD`. There is an open position remaining (2 units of stock1, which correspond to the second buy transaction).  When we add this sell: - 2021-06-07: sell 2 stock1 for 400 USD each  It would add a second complete trade with a profit of `(400*2)-(200*2)=800-400=400 USD`.  For some brokers, the order history may be incomplete (e.g. only reveals the latest 90 days), so that we do not know if there could be older transactions. Thus, our implementation might detect (given the current set of open positions together with the list of order executions) that we cannot figure out the corresponding opening transactions for a closing transaction. Affected trades will be ignored for this analysis and might appear as warning items in the `/warnings` endpoint. Frontends should show those warnings so that users can understand why the analysis is incomplete.
   */
  async getPortfolioTrades(
    requestParameters: GetPortfolioTradesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<GetPortfolioTradesResponse> {
    const response = await this.getPortfolioTradesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async getPortfoliosRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<PortfoliosResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PortfoliosResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async getPortfolios(
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<PortfoliosResponse> {
    const response = await this.getPortfoliosRaw(initOverrides);
    return await response.value();
  }

  /**
   * This endpoint can be used to rename the display name of a specified portfolio. To restore the original portfolio name, send a rename request with an empty string as the new name. **Note**: This does not change the original portfolio name at your broker.
   */
  async renamePortfolioRaw(
    requestParameters: RenamePortfolioOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.portfolioId === null ||
      requestParameters.portfolioId === undefined
    ) {
      throw new runtime.RequiredError(
        "portfolioId",
        "Required parameter requestParameters.portfolioId was null or undefined when calling renamePortfolio."
      );
    }

    if (
      requestParameters.renamePortfolioRequest === null ||
      requestParameters.renamePortfolioRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "renamePortfolioRequest",
        "Required parameter requestParameters.renamePortfolioRequest was null or undefined when calling renamePortfolio."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("idToken", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/portfolios/{portfolioId}/rename`.replace(
          `{${"portfolioId"}}`,
          encodeURIComponent(String(requestParameters.portfolioId))
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RenamePortfolioRequestToJSON(
          requestParameters.renamePortfolioRequest
        ),
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * This endpoint can be used to rename the display name of a specified portfolio. To restore the original portfolio name, send a rename request with an empty string as the new name. **Note**: This does not change the original portfolio name at your broker.
   */
  async renamePortfolio(
    requestParameters: RenamePortfolioOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<void> {
    await this.renamePortfolioRaw(requestParameters, initOverrides);
  }
}
