/* tslint:disable */
/* eslint-disable */
/**
 * brokerize
 * The brokerize API allows clients to implement multi-brokerage with a unified interface. For more information, visit brokerize.com
 *
 * The version of the OpenAPI document: 0.0.1-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Challenge,
    ChallengeFromJSON,
    ChallengeToJSON,
    CreateOrderChallengeParams,
    CreateOrderChallengeParamsFromJSON,
    CreateOrderChallengeParamsToJSON,
    CreateOrderParams,
    CreateOrderParamsFromJSON,
    CreateOrderParamsToJSON,
    CreateTradeResponse,
    CreateTradeResponseFromJSON,
    CreateTradeResponseToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    GenericTable,
    GenericTableFromJSON,
    GenericTableToJSON,
    GetCostEstimationParams,
    GetCostEstimationParamsFromJSON,
    GetCostEstimationParamsToJSON,
    GetQuoteParams,
    GetQuoteParamsFromJSON,
    GetQuoteParamsToJSON,
    GetQuoteResponse,
    GetQuoteResponseFromJSON,
    GetQuoteResponseToJSON,
    OrderCostEstimation,
    OrderCostEstimationFromJSON,
    OrderCostEstimationToJSON,
    PrepareTradeResponse,
    PrepareTradeResponseFromJSON,
    PrepareTradeResponseToJSON,
} from '../models';

export interface CreateTradeRequest {
    createOrderParams: CreateOrderParams;
}

export interface CreateTradeChallengeRequest {
    createOrderChallengeParams: CreateOrderChallengeParams;
}

export interface GetCostEstimationRequest {
    getCostEstimationParams: GetCostEstimationParams;
}

export interface GetQuoteRequest {
    portfolioId: string;
    getQuoteParams: GetQuoteParams;
}

export interface GetSecurityDetailedInfoRequest {
    token: string;
}

export interface PrepareTradeRequest {
    isin: string;
    portfolioId: string;
}

/**
 * 
 */
export class TradeApi extends runtime.BaseAPI {

    /**
     * Create a trade.  It is possible that the broker rejects the order because of some extra hints that the user must accept (which can not be figured out in `prepareTrade`, e.g. because the order volume has to be determined first). In thise case, the `MUST_ACCEPT_HINT` error code is returned. The user can choose to accept that hint. If that is the case, the request can be retried with the `acceptHintId` parameter.
     */
    async createTradeRaw(requestParameters: CreateTradeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<CreateTradeResponse>> {
        if (requestParameters.createOrderParams === null || requestParameters.createOrderParams === undefined) {
            throw new runtime.RequiredError('createOrderParams','Required parameter requestParameters.createOrderParams was null or undefined when calling createTrade.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-brkrz-client-id"] = this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-access-token"] = this.configuration.apiKey("x-access-token"); // idToken authentication
        }

        const response = await this.request({
            path: `/trade/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrderParamsToJSON(requestParameters.createOrderParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTradeResponseFromJSON(jsonValue));
    }

    /**
     * Create a trade.  It is possible that the broker rejects the order because of some extra hints that the user must accept (which can not be figured out in `prepareTrade`, e.g. because the order volume has to be determined first). In thise case, the `MUST_ACCEPT_HINT` error code is returned. The user can choose to accept that hint. If that is the case, the request can be retried with the `acceptHintId` parameter.
     */
    async createTrade(requestParameters: CreateTradeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<CreateTradeResponse> {
        const response = await this.createTradeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If the user chose an auth method from `GetAuthInfo` with the flow `CHALLENGE_RESPONSE`, before creating a trade, a challenge must be requested first. If any other flow is used, a challenge *must not* be requested.
     */
    async createTradeChallengeRaw(requestParameters: CreateTradeChallengeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Challenge>> {
        if (requestParameters.createOrderChallengeParams === null || requestParameters.createOrderChallengeParams === undefined) {
            throw new runtime.RequiredError('createOrderChallengeParams','Required parameter requestParameters.createOrderChallengeParams was null or undefined when calling createTradeChallenge.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-brkrz-client-id"] = this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-access-token"] = this.configuration.apiKey("x-access-token"); // idToken authentication
        }

        const response = await this.request({
            path: `/trade/challenge`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrderChallengeParamsToJSON(requestParameters.createOrderChallengeParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChallengeFromJSON(jsonValue));
    }

    /**
     * If the user chose an auth method from `GetAuthInfo` with the flow `CHALLENGE_RESPONSE`, before creating a trade, a challenge must be requested first. If any other flow is used, a challenge *must not* be requested.
     */
    async createTradeChallenge(requestParameters: CreateTradeChallengeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Challenge> {
        const response = await this.createTradeChallengeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getCostEstimationRaw(requestParameters: GetCostEstimationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<OrderCostEstimation>> {
        if (requestParameters.getCostEstimationParams === null || requestParameters.getCostEstimationParams === undefined) {
            throw new runtime.RequiredError('getCostEstimationParams','Required parameter requestParameters.getCostEstimationParams was null or undefined when calling getCostEstimation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-brkrz-client-id"] = this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-access-token"] = this.configuration.apiKey("x-access-token"); // idToken authentication
        }

        const response = await this.request({
            path: `/trade/costEstimation`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetCostEstimationParamsToJSON(requestParameters.getCostEstimationParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderCostEstimationFromJSON(jsonValue));
    }

    /**
     */
    async getCostEstimation(requestParameters: GetCostEstimationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<OrderCostEstimation> {
        const response = await this.getCostEstimationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a quote to use with `orderModel=quote`. The actual quote trade is then performed using `createTradeChallenge` / `createTrade` as for other orderModels.
     */
    async getQuoteRaw(requestParameters: GetQuoteRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<GetQuoteResponse>> {
        if (requestParameters.portfolioId === null || requestParameters.portfolioId === undefined) {
            throw new runtime.RequiredError('portfolioId','Required parameter requestParameters.portfolioId was null or undefined when calling getQuote.');
        }

        if (requestParameters.getQuoteParams === null || requestParameters.getQuoteParams === undefined) {
            throw new runtime.RequiredError('getQuoteParams','Required parameter requestParameters.getQuoteParams was null or undefined when calling getQuote.');
        }

        const queryParameters: any = {};

        if (requestParameters.portfolioId !== undefined) {
            queryParameters['portfolioId'] = requestParameters.portfolioId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-brkrz-client-id"] = this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-access-token"] = this.configuration.apiKey("x-access-token"); // idToken authentication
        }

        const response = await this.request({
            path: `/trade/quote`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetQuoteParamsToJSON(requestParameters.getQuoteParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetQuoteResponseFromJSON(jsonValue));
    }

    /**
     * Get a quote to use with `orderModel=quote`. The actual quote trade is then performed using `createTradeChallenge` / `createTrade` as for other orderModels.
     */
    async getQuote(requestParameters: GetQuoteRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<GetQuoteResponse> {
        const response = await this.getQuoteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getSecurityDetailedInfoRaw(requestParameters: GetSecurityDetailedInfoRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<GenericTable>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getSecurityDetailedInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.token !== undefined) {
            queryParameters['token'] = requestParameters.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-brkrz-client-id"] = this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-access-token"] = this.configuration.apiKey("x-access-token"); // idToken authentication
        }

        const response = await this.request({
            path: `/trade/securityDetails`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenericTableFromJSON(jsonValue));
    }

    /**
     */
    async getSecurityDetailedInfo(requestParameters: GetSecurityDetailedInfoRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<GenericTable> {
        const response = await this.getSecurityDetailedInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Prepare a trade of `isin` in the given portfolio `portfolioId`. This describes what kind of orders are supported by the broker for the security. This requires the portfolio to have at least one active broker session.
     */
    async prepareTradeRaw(requestParameters: PrepareTradeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<PrepareTradeResponse>> {
        if (requestParameters.isin === null || requestParameters.isin === undefined) {
            throw new runtime.RequiredError('isin','Required parameter requestParameters.isin was null or undefined when calling prepareTrade.');
        }

        if (requestParameters.portfolioId === null || requestParameters.portfolioId === undefined) {
            throw new runtime.RequiredError('portfolioId','Required parameter requestParameters.portfolioId was null or undefined when calling prepareTrade.');
        }

        const queryParameters: any = {};

        if (requestParameters.isin !== undefined) {
            queryParameters['isin'] = requestParameters.isin;
        }

        if (requestParameters.portfolioId !== undefined) {
            queryParameters['portfolioId'] = requestParameters.portfolioId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-brkrz-client-id"] = this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-access-token"] = this.configuration.apiKey("x-access-token"); // idToken authentication
        }

        const response = await this.request({
            path: `/trade/prepare`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PrepareTradeResponseFromJSON(jsonValue));
    }

    /**
     * Prepare a trade of `isin` in the given portfolio `portfolioId`. This describes what kind of orders are supported by the broker for the security. This requires the portfolio to have at least one active broker session.
     */
    async prepareTrade(requestParameters: PrepareTradeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<PrepareTradeResponse> {
        const response = await this.prepareTradeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
