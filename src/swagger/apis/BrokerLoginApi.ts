/* tslint:disable */
/* eslint-disable */
/**
 * brokerize
 * The brokerize API allows clients to implement multi-brokerage with a unified interface. For more information, visit brokerize.com
 *
 * The version of the OpenAPI document: 0.0.1-preview
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  AddSessionCompleteChallengeParams,
  AddSessionCompleteChallengeParamsFromJSON,
  AddSessionCompleteChallengeParamsToJSON,
  AddSessionParams,
  AddSessionParamsFromJSON,
  AddSessionParamsToJSON,
  ConfirmOAuthParams,
  ConfirmOAuthParamsFromJSON,
  ConfirmOAuthParamsToJSON,
  ConfirmOAuthResponse,
  ConfirmOAuthResponseFromJSON,
  ConfirmOAuthResponseToJSON,
  ErrorResponse,
  ErrorResponseFromJSON,
  ErrorResponseToJSON,
  LoginResponse,
  LoginResponseFromJSON,
  LoginResponseToJSON,
  LoginResponseReady,
  LoginResponseReadyFromJSON,
  LoginResponseReadyToJSON,
  PrepareOAuthRedirectParams,
  PrepareOAuthRedirectParamsFromJSON,
  PrepareOAuthRedirectParamsToJSON,
  PrepareOAuthRedirectResponse,
  PrepareOAuthRedirectResponseFromJSON,
  PrepareOAuthRedirectResponseToJSON,
} from "../models";

export interface AddSessionRequest {
  addSessionParams: AddSessionParams;
}

export interface AddSessionCompleteChallengeRequest {
  addSessionCompleteChallengeParams: AddSessionCompleteChallengeParams;
}

export interface ConfirmOAuthRequest {
  confirmOAuthParams: ConfirmOAuthParams;
}

export interface PrepareOAuthRedirectRequest {
  prepareOAuthRedirectParams: PrepareOAuthRedirectParams;
}

/**
 *
 */
export class BrokerLoginApi extends runtime.BaseAPI {
  /**
   */
  async addSessionRaw(
    requestParameters: AddSessionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<LoginResponse>> {
    if (
      requestParameters.addSessionParams === null ||
      requestParameters.addSessionParams === undefined
    ) {
      throw new runtime.RequiredError(
        "addSessionParams",
        "Required parameter requestParameters.addSessionParams was null or undefined when calling addSession."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-access-token"] =
        this.configuration.apiKey("x-access-token"); // idToken authentication
    }

    const response = await this.request(
      {
        path: `/sessions`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AddSessionParamsToJSON(requestParameters.addSessionParams),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LoginResponseFromJSON(jsonValue)
    );
  }

  /**
   */
  async addSession(
    requestParameters: AddSessionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<LoginResponse> {
    const response = await this.addSessionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * If login returns the state `challenge`, the login must be completed by providing a challenge response first.
   */
  async addSessionCompleteChallengeRaw(
    requestParameters: AddSessionCompleteChallengeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<LoginResponseReady>> {
    if (
      requestParameters.addSessionCompleteChallengeParams === null ||
      requestParameters.addSessionCompleteChallengeParams === undefined
    ) {
      throw new runtime.RequiredError(
        "addSessionCompleteChallengeParams",
        "Required parameter requestParameters.addSessionCompleteChallengeParams was null or undefined when calling addSessionCompleteChallenge."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-access-token"] =
        this.configuration.apiKey("x-access-token"); // idToken authentication
    }

    const response = await this.request(
      {
        path: `/sessions/completeLogin`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AddSessionCompleteChallengeParamsToJSON(
          requestParameters.addSessionCompleteChallengeParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LoginResponseReadyFromJSON(jsonValue)
    );
  }

  /**
   * If login returns the state `challenge`, the login must be completed by providing a challenge response first.
   */
  async addSessionCompleteChallenge(
    requestParameters: AddSessionCompleteChallengeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<LoginResponseReady> {
    const response = await this.addSessionCompleteChallengeRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * For brokers with OAuth login processes, this adds the session to the user\'s account after redirects happen. Only the user that is redirected from the broker login in the browser will receive the `code`. This step ensures that the logged-in user at brokerize is actually the one that has gone through the broker OAuth steps.
   */
  async confirmOAuthRaw(
    requestParameters: ConfirmOAuthRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<ConfirmOAuthResponse>> {
    if (
      requestParameters.confirmOAuthParams === null ||
      requestParameters.confirmOAuthParams === undefined
    ) {
      throw new runtime.RequiredError(
        "confirmOAuthParams",
        "Required parameter requestParameters.confirmOAuthParams was null or undefined when calling confirmOAuth."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-access-token"] =
        this.configuration.apiKey("x-access-token"); // idToken authentication
    }

    const response = await this.request(
      {
        path: `/sessions/confirmOAuth`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ConfirmOAuthParamsToJSON(requestParameters.confirmOAuthParams),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConfirmOAuthResponseFromJSON(jsonValue)
    );
  }

  /**
   * For brokers with OAuth login processes, this adds the session to the user\'s account after redirects happen. Only the user that is redirected from the broker login in the browser will receive the `code`. This step ensures that the logged-in user at brokerize is actually the one that has gone through the broker OAuth steps.
   */
  async confirmOAuth(
    requestParameters: ConfirmOAuthRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<ConfirmOAuthResponse> {
    const response = await this.confirmOAuthRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * For brokers with `isOAuth`, sessions can not be created using `AddSession`. This is how a session can be added for an OAuth-based login process:  1. use `prepareOAuthRedirect` to obtain a URL to redirect to. You can provide a `returnTo` URL which will be redirect to later. Note that a list of allowed URLs has to be configured for the client. 2. redirect the user\'s browser to the `redirectTo` URL 3. after the user has logged in at the broker\'s interface, a redirect to `returnTo` with the URL query parameters `verifysession=1`, `code` and `ticketId` will happen 4. the `returnTo` page must call `confirmOAuth` with the given `ticketId` and `code` to finally add the session to the user\'s account
   */
  async prepareOAuthRedirectRaw(
    requestParameters: PrepareOAuthRedirectRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<runtime.ApiResponse<PrepareOAuthRedirectResponse>> {
    if (
      requestParameters.prepareOAuthRedirectParams === null ||
      requestParameters.prepareOAuthRedirectParams === undefined
    ) {
      throw new runtime.RequiredError(
        "prepareOAuthRedirectParams",
        "Required parameter requestParameters.prepareOAuthRedirectParams was null or undefined when calling prepareOAuthRedirect."
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-brkrz-client-id"] =
        this.configuration.apiKey("x-brkrz-client-id"); // clientId authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["x-access-token"] =
        this.configuration.apiKey("x-access-token"); // idToken authentication
    }

    const response = await this.request(
      {
        path: `/sessions/prepareOAuthRedirect`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PrepareOAuthRedirectParamsToJSON(
          requestParameters.prepareOAuthRedirectParams
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PrepareOAuthRedirectResponseFromJSON(jsonValue)
    );
  }

  /**
   * For brokers with `isOAuth`, sessions can not be created using `AddSession`. This is how a session can be added for an OAuth-based login process:  1. use `prepareOAuthRedirect` to obtain a URL to redirect to. You can provide a `returnTo` URL which will be redirect to later. Note that a list of allowed URLs has to be configured for the client. 2. redirect the user\'s browser to the `redirectTo` URL 3. after the user has logged in at the broker\'s interface, a redirect to `returnTo` with the URL query parameters `verifysession=1`, `code` and `ticketId` will happen 4. the `returnTo` page must call `confirmOAuth` with the given `ticketId` and `code` to finally add the session to the user\'s account
   */
  async prepareOAuthRedirect(
    requestParameters: PrepareOAuthRedirectRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction
  ): Promise<PrepareOAuthRedirectResponse> {
    const response = await this.prepareOAuthRedirectRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}
